var documenterSearchIndex = {"docs":
[{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"CUTEst.jl relies on SIF files to create a CUTEstModel. Three sets of SIF files are available on Bitbucket. We can easily switch between these sets using the function set_mastsif.","category":"page"},{"location":"sifdecoder/#CUTEst.set_mastsif","page":"Managing SIF files","title":"CUTEst.set_mastsif","text":"set_mastsif(set::String=\"sifcollection\")\n\nSet the environment variable MASTSIF to point to a set of SIF problems. The supported sets are:\n\n\"sifcollection\": the CUTEst NLP test set;\n\"maros-meszaros\": the Maros-Meszaros QP test set;\n\"netlib-lp\": the Netlib LP test set.\n\n\n\n\n\n","category":"function"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"note: Note\nIf the environment variable MASTSIF is not set, using CUTEst will automatically load the set \"sifcollection\".","category":"page"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"To have the list of SIF problems available in the current set, use the function list_sif_problems.","category":"page"},{"location":"sifdecoder/#CUTEst.list_sif_problems","page":"Managing SIF files","title":"CUTEst.list_sif_problems","text":"problems = list_sif_problems()\n\nOutput\n\nproblems::Vector{String}: A list of SIF problems (without the extension .SIF) available in the current set.\n\nSee set_mastsif for more details about how to change the set of SIF files.\n\n\n\n\n\n","category":"function"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"Given a problem name in the defined set, we need to decode the SIF files, which will generate corresponding Fortran files.","category":"page"},{"location":"sifdecoder/#CUTEst.sifdecoder","page":"Managing SIF files","title":"CUTEst.sifdecoder","text":"sifdecoder(name::String, args...; verbose::Bool=false,\n           precision::Symbol=:double, libsif_folder=libsif_path)\n\nDecodes a SIF problem, converting it into a format suitable for further processing.\n\nArguments\n\nname::String: The path or name of the SIF problem, with or without the extension .SIF.\nargs...: Additional arguments passed directly to the SIF decoder. Relevant for problems with variable sizes.\nverbose::Bool: If true, enables verbose output during the decoding process. Defaults to false.\nprecision::Symbol: The desired precision for the problem. Can be :single, :double (default), or :quadruple.\nlibsif_folder::String: The directory where the generated files (*.f and *.d) will be stored. Defaults to libsif_path.\n\nsifdecoder(\"HS1.SIF\", precision=:single)\nsifdecoder(\"DIXMAANJ\", \"-param\", \"M=30\"; precision=:double, verbose=true)\nsifdecoder(\"/home/alexis/CUTEst/BROWNDEN.SIF\", precision=:quadruple)\n\n\n\n\n\n","category":"function"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"Next, we need to compile these Fortran files and create a shared library linked with a CUTEst library for a given precision (single, double, or quadruple). The CUTEst library provides generic routines to evaluate objectives, constraints, gradients, Jacobians, Hessians, etc.","category":"page"},{"location":"sifdecoder/#CUTEst.build_libsif","page":"Managing SIF files","title":"CUTEst.build_libsif","text":"build_libsif(name::String; precision::Symbol=:double, standalone::Bool=false,\n             libsif_folder::String=libsif_path)\n\nBuilds a shared library from a decoded SIF problem.\n\nArguments\n\nname::String: The path or name of the SIF problem, with or without the extension .SIF.\nprecision::Symbol: The desired precision of the problem. Can be :single, :double (default), or :quadruple.\nstandalone::Bool: If true, creates a standalone shared library for the SIF problem without requiring CUTEst. Only relevant to GALAHAD.jl. Defaults to false.\nlibsif_folder::String: The directory where the compiled library will be stored. Defaults to libsif_path.\n\nwarning: Warning\nWe expect that the SIF problem has been decoded in libsif_folder and contains the generated files (*.f and *.d).\n\nbuild_libsif(\"HS1.SIF\", precision=:single)\nbuild_libsif(\"DIXMAANJ\", precision=:double)\nbuild_libsif(\"/home/alexis/CUTEst/BROWNDEN.SIF\", precision=:quadruple)\n\n\n\n\n\n","category":"function"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"note: Note\nWhen creating a CUTEstModel, the functions sifdecoder and build_libsif are called automatically.","category":"page"},{"location":"sifdecoder/","page":"Managing SIF files","title":"Managing SIF files","text":"These additional files are generated in the folder deps/files at the root of the installation directory of CUTEst.jl . The path to this folder is available via CUTEst.libsif_path. We provide two functions to delete these files:","category":"page"},{"location":"sifdecoder/#CUTEst.manage_libsif","page":"Managing SIF files","title":"CUTEst.manage_libsif","text":"manage_libsif(; sort_by::Symbol=:name, rev::Bool=false)\n\nOpens a prompt allowing the user to selectively remove compiled libraries for SIF problems. Data files OUTSDIF_*.d, which store preprocessed information required for automatic differentiation within CUTEst, are also removed.\n\nBy default, the problems are sorted by name. Alternatively, you can sort them by file size on disk by specifying sort_by=:size. Use rev=true to reverse the sort order.\n\nNote: Shared libraries for SIF problems compiled with standalone = true can only be removed using the function clear_libsif.\n\n\n\n\n\n","category":"function"},{"location":"sifdecoder/#CUTEst.clear_libsif","page":"Managing SIF files","title":"CUTEst.clear_libsif","text":"clear_libsif()\n\nRemoves all compiled libraries and data files associated with SIF problems.\n\n\n\n\n\n","category":"function"},{"location":"core/#Working-with-CUTEst-directly","page":"Using CUTEst core functions","title":"Working with CUTEst directly","text":"","category":"section"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"When working with CUTEst, we created a core interface, which is essentially an interface for the core CUTEst functions. The core interface is implemented in core_interface.jl. However, you probably won't want to use this directly because the NLPModels interface is much more user-friendly and just as effective. For more information, see its tutorial.","category":"page"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"CUTEst.jl calls Fortran routines from CUTEst via Julia wrappers in libcutest.jl.","category":"page"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"For each of these routines, we dropped the prefix cutest_ and the suffixes _s_, _, and _q_. For example, the functions cutest_ufn_s_, cutest_ufn_, and cutest_ufn_q_ are all available as ufn. The ufn function takes an additional argument T in the first position, where T can be Float32, Float64, or Float128. This allows for a unified interface to the routines in single, double, and quadruple precision.","category":"page"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"Only use these functions if you really know what you're doing.","category":"page"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"If you want to use these functions, you should still decode the problem as an NLP by doing the following:","category":"page"},{"location":"core/","page":"Using CUTEst core functions","title":"Using CUTEst core functions","text":"using CUTEst, Quadmath\n\n# Float32, Float64 and Float128 are supported\nT = Float64\nnlp = CUTEstModel{T}(\"CHAIN\")\nx = rand(T, nlp.meta.nvar)\nf = Ref{T}()\nCUTEst.ufn(T, nlp.libsif, nlp.status, nlp.nvar, x, f)\nprintln(f[])","category":"page"},{"location":"core/#CUTEst.cjprod","page":"Using CUTEst core functions","title":"CUTEst.cjprod","text":"cjprod(T, libsif, status, n, m, gotj, jtrans, x, vector, lvector, result, lresult)\n\nThe cjprod subroutine forms the product of a vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\ngotj:    [IN]  Vector{Bool}\njtrans:  [IN]  Vector{Bool}\nx:       [IN]  Vector{T}\nvector:  [IN]  Vector{T}\nlvector: [IN]  Vector{Cint}\nresult:  [OUT] Vector{T}\nlresult: [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ccfg","page":"Using CUTEst core functions","title":"CUTEst.ccfg","text":"ccfg(T, libsif, status, n, m, x, c, jtrans, lcjac1, lcjac2, cjac, grad)\n\nThe ccfg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nc:       [OUT] Vector{T}\njtrans:  [IN]  Vector{Bool}\nlcjac1:  [IN]  Vector{Cint}\nlcjac2:  [IN]  Vector{Cint}\ncjac:    [OUT] Matrix{T}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ccf","page":"Using CUTEst core functions","title":"CUTEst.ccf","text":"ccf(T, libsif, status, n, m, x, c)\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cish","page":"Using CUTEst core functions","title":"CUTEst.cish","text":"cish(T, libsif, status, n, x, iprob, nnzh, lh, h_val, h_row, h_col)\n\nThe cish subroutine evaluates the Hessian of a particular constraint function or the objective function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\niprob:   [IN]  Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ushprod","page":"Using CUTEst core functions","title":"CUTEst.ushprod","text":"ushprod(T, libsif, status, n, goth, x, nnz_vector, index_nz_vector, vector, nnz_result, index_nz_result, result)\n\nThe ushprod subroutine forms the product of a sparse vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:          [OUT] Vector{Cint}\nn:               [IN]  Vector{Cint}\ngoth:            [IN]  Vector{Bool}\nx:               [IN]  Vector{T}\nnnz_vector:      [IN]  Vector{Cint}\nindexnzvector: [IN]  Vector{Cint}\nvector:          [IN]  Vector{T}\nnnz_result:      [OUT] Vector{Cint}\nindexnzresult: [OUT] Vector{Cint}\nresult:          [OUT] Vector{T}\n\nNotice that vector and result should have allocated dimension of n.\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdimchp","page":"Using CUTEst core functions","title":"CUTEst.cdimchp","text":"cdimchp(T, libsif, status, nnzchp)\n\nThe cdimchp subroutine determines the number of nonzero elements required to store the products of the Hessian matrices of the constraint functions with a specified vector for the problem decoded into OUTSDIF.d in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nnnzchp:  [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ureport","page":"Using CUTEst core functions","title":"CUTEst.ureport","text":"ureport(T, libsif, status, calls, time)\n\nThe ureport subroutine obtains statistics concerning function evaluation and CPU time used for unconstrained or bound-constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:  [OUT] Vector{Cint}\ncalls:   [OUT] Vector{T}\ntime:    [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.chcprod","page":"Using CUTEst core functions","title":"CUTEst.chcprod","text":"chcprod(T, libsif, status, n, m, goth, x, y, vector, result)\n\nThe chcprod subroutine forms the product of a vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) of the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\ngoth:    [IN]  Vector{Bool}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nvector:  [IN]  Vector{T}\nresult:  [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.udimse","page":"Using CUTEst core functions","title":"CUTEst.udimse","text":"udimse(T, libsif, status, ne, he_val_ne, he_row_ne)\n\nThe udimse subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H_i involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:    [OUT] Vector{Cint}\nne:        [OUT] Vector{Cint}\nhevalne: [OUT] Vector{Cint}\nherowne: [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ubandh","page":"Using CUTEst core functions","title":"CUTEst.ubandh","text":"ubandh(T, libsif, status, n, x, semibandwidth, h_band, lbandh, max_semibandwidth)\n\nThe ubandh subroutine extracts the elements which lie within a band of given semi-bandwidth out of the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:            [OUT] Vector{Cint}\nn:                 [IN]  Vector{Cint}\nx:                 [IN]  Vector{T}\nsemibandwidth:     [IN]  Vector{Cint}\nh_band:            [OUT] Matrix{T}\nlbandh:            [IN]  Vector{Cint}\nmax_semibandwidth: [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csjp","page":"Using CUTEst core functions","title":"CUTEst.csjp","text":"csjp(T, libsif, status, nnzj, lj, jvar, jcon)\n\nThe csjp subroutine evaluates the sparsity pattern of the Jacobian of the constraints for a problem decoded from a SIF file by the script sifdecoder.\n\nstatus:  [OUT] Vector{Cint}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\njvar:    [OUT] Vector{Cint}\njcon:    [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cgr","page":"Using CUTEst core functions","title":"CUTEst.cgr","text":"cgr(T, libsif, status, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val)\n\nThe cgr subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\ngrlagf:  [IN]  Vector{Bool}\ng:       [OUT] Vector{T}\njtrans:  [IN]  Vector{Bool}\nlj1:     [IN]  Vector{Cint}\nlj2:     [IN]  Vector{Cint}\nj_val:   [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ufn","page":"Using CUTEst core functions","title":"CUTEst.ufn","text":"ufn(T, libsif, status, n, x, f)\n\nThe ufn subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csgrp","page":"Using CUTEst core functions","title":"CUTEst.csgrp","text":"csgrp(T, libsif, status, n, nnzj, lj, j_var, j_fun)\n\nThe csgrp subroutine evaluates sparsity pattern used when storing the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\nj_var:   [OUT] Vector{Cint}\nj_fun:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cshc","page":"Using CUTEst core functions","title":"CUTEst.cshc","text":"cshc(T, libsif, status, n, m, x, y, nnzh, lh, h_val, h_row, h_col)\n\nThe cshc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdimsj","page":"Using CUTEst core functions","title":"CUTEst.cdimsj","text":"cdimsj(T, libsif, status, nnzj)\n\nThe cdimsj subroutine determines the number of nonzero elements required to store the matrix of gradients of the objective function and constraint functions for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nnnzj:    [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cfn","page":"Using CUTEst core functions","title":"CUTEst.cfn","text":"cfn(T, libsif, status, n, m, x, f, c)\n\nThe cfn subroutine evaluates the value of the objective function and general constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\nc:       [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cofg","page":"Using CUTEst core functions","title":"CUTEst.cofg","text":"cofg(T, libsif, status, n, x, f, g, grad)\n\nThe cofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\ng:       [OUT] Vector{T}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cofsg","page":"Using CUTEst core functions","title":"CUTEst.cofsg","text":"cofsg(T, libsif, status, n, x, f, nnzg, lg, g_val, g_var, grad)\n\nThe cofsg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\nnnzg:    [OUT] Vector{Cint}\nlg:      [IN]  Vector{Cint}\ng_val:   [OUT] Vector{T}\ng_var:   [OUT] Vector{Cint}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ceh","page":"Using CUTEst core functions","title":"CUTEst.ceh","text":"ceh(T, libsif, status, n, m, x, y, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)\n\nThe ceh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:     [OUT] Vector{Cint}\nn:          [IN]  Vector{Cint}\nm:          [IN]  Vector{Cint}\nx:          [IN]  Vector{T}\ny:          [IN]  Vector{T}\nne:         [OUT] Vector{Cint}\nlhe_ptr:    [IN]  Vector{Cint}\nherowptr: [OUT] Vector{Cint}\nhevalptr: [OUT] Vector{Cint}\nlhe_row:    [IN]  Vector{Cint}\nhe_row:     [OUT] Vector{Cint}\nlhe_val:    [IN]  Vector{Cint}\nhe_val:     [OUT] Vector{T}\nbyrows:     [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdimsh","page":"Using CUTEst core functions","title":"CUTEst.cdimsh","text":"cdimsh(T, libsif, status, nnzh)\n\nThe cdimsh subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse \"coordinate\" format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ugr","page":"Using CUTEst core functions","title":"CUTEst.ugr","text":"ugr(T, libsif, status, n, x, g)\n\nThe ugr subroutine evaluates the gradient of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ng:       [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cshcprod","page":"Using CUTEst core functions","title":"CUTEst.cshcprod","text":"cshcprod(T, libsif, status, n, m, goth, x, y, nnz_vector, index_nz_vector, vector, nnz_result, index_nz_result, result)\n\nThe cshcprod subroutine forms the product of a sparse vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:          [OUT] Vector{Cint}\nn:               [IN]  Vector{Cint}\nm:               [IN]  Vector{Cint}\ngoth:            [IN]  Vector{Bool}\nx:               [IN]  Vector{T}\ny:               [IN]  Vector{T}\nnnz_vector:      [IN]  Vector{Cint}\nindexnzvector: [IN]  Vector{Cint}\nvector:          [IN]  Vector{T}\nnnz_result:      [OUT] Vector{Cint}\nindexnzresult: [OUT] Vector{Cint}\nresult:          [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.uhprod","page":"Using CUTEst core functions","title":"CUTEst.uhprod","text":"uhprod(T, libsif, status, n, goth, x, vector, result)\n\nThe uhprod subroutine forms the product of a vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\ngoth:    [IN]  Vector{Bool}\nx:       [IN]  Vector{T}\nvector:  [IN]  Vector{T}\nresult:  [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csgreh","page":"Using CUTEst core functions","title":"CUTEst.csgreh","text":"csgreh(T, libsif, status, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)\n\nThe csgreh subroutine evaluates both the gradients of the general constraint functions and the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The subroutine also obtains the gradient of either the objective function or the Lagrangian function, stored in a sparse format. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:     [OUT] Vector{Cint}\nn:          [IN]  Vector{Cint}\nm:          [IN]  Vector{Cint}\nx:          [IN]  Vector{T}\ny:          [IN]  Vector{T}\ngrlagf:     [IN]  Vector{Bool}\nnnzj:       [OUT] Vector{Cint}\nlj:         [IN]  Vector{Cint}\nj_val:      [OUT] Vector{T}\nj_var:      [OUT] Vector{Cint}\nj_fun:      [OUT] Vector{Cint}\nne:         [OUT] Vector{Cint}\nlhe_ptr:    [IN]  Vector{Cint}\nherowptr: [OUT] Vector{Cint}\nhevalptr: [OUT] Vector{Cint}\nlhe_row:    [IN]  Vector{Cint}\nhe_row:     [OUT] Vector{Cint}\nlhe_val:    [IN]  Vector{Cint}\nhe_val:     [OUT] Vector{T}\nbyrows:     [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.uterminate","page":"Using CUTEst core functions","title":"CUTEst.uterminate","text":"uterminate(T, libsif, status)\n\nThe uterminate subroutine deallocates all workspace arrays created since the last call to usetup.\n\nstatus:  [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ugreh","page":"Using CUTEst core functions","title":"CUTEst.ugreh","text":"ugreh(T, libsif, status, n, x, g, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)\n\nThe ugreh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H sub e involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:     [OUT] Vector{Cint}\nn:          [IN]  Vector{Cint}\nx:          [IN]  Vector{T}\ng:          [OUT] Vector{T}\nne:         [OUT] Vector{Cint}\nlhe_ptr:    [IN]  Vector{Cint}\nherowptr: [OUT] Vector{Cint}\nhevalptr: [OUT] Vector{Cint}\nlhe_row:    [IN]  Vector{Cint}\nhe_row:     [OUT] Vector{Cint}\nlhe_val:    [IN]  Vector{Cint}\nhe_val:     [OUT] Vector{T}\nbyrows:     [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cigr","page":"Using CUTEst core functions","title":"CUTEst.cigr","text":"cigr(T, libsif, status, n, iprob, x, g_val)\n\nThe cigr subroutine evaluates the gradient of either the objective function or a constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\niprob:   [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ng_val:   [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.clfg","page":"Using CUTEst core functions","title":"CUTEst.clfg","text":"clfg(T, libsif, status, n, m, x, y, f, g, grad)\n\nThe clfg subroutine evaluates the value of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (X,Y), and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\ng:       [OUT] Vector{T}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ugrdh","page":"Using CUTEst core functions","title":"CUTEst.ugrdh","text":"ugrdh(T, libsif, status, n, x, g, lh1, h)\n\nThe ugrdh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ng:       [OUT] Vector{T}\nlh1:     [IN]  Vector{Cint}\nh:       [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdhc","page":"Using CUTEst core functions","title":"CUTEst.cdhc","text":"cdhc(T, libsif, status, n, m, x, y, lh1, h_val)\n\nThe cdhc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nlh1:     [IN]  Vector{Cint}\nh_val:   [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.fclose","page":"Using CUTEst core functions","title":"CUTEst.fclose","text":"fclose(T, libsif, funit, status)\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csetup","page":"Using CUTEst core functions","title":"CUTEst.csetup","text":"csetup(libsif, status, input, out, io_buffer, n, m, x, x_l, x_u, y, c_l, c_u, equatn, linear, e_order, l_order, v_order)\n\nThe csetup subroutine sets up the correct data structures for subsequent computations on the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:    [OUT] Vector{Cint}\ninput:     [IN]  Vector{Cint}\nout:       [IN]  Vector{Cint}\nio_buffer: [IN]  Vector{Cint}\nn:         [IN]  Vector{Cint}\nm:         [IN]  Vector{Cint}\nx:         [OUT] Vector{T}\nx_l:       [OUT] Vector{T}\nx_u:       [OUT] Vector{T}\ny:         [OUT] Vector{T}\nc_l:       [OUT] Vector{T}\nc_u:       [OUT] Vector{T}\nequatn:    [OUT] Vector{Bool}\nlinear:    [OUT] Vector{Bool}\ne_order:   [IN]  Vector{Cint}\nl_order:   [IN]  Vector{Cint}\nv_order:   [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ccifg","page":"Using CUTEst core functions","title":"CUTEst.ccifg","text":"ccifg(T, libsif, status, n, icon, x, ci, gci, grad)\n\nThe ccifg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nicon:    [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nci:      [OUT] Vector{T}\ngci:     [OUT] Vector{T}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cvartype","page":"Using CUTEst core functions","title":"CUTEst.cvartype","text":"cvartype(T, libsif, status, n, x_type)\n\nThe cvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx_type:  [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.udimsh","page":"Using CUTEst core functions","title":"CUTEst.udimsh","text":"udimsh(T, libsif, status, nnzh)\n\nThe udimsh subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csjprod","page":"Using CUTEst core functions","title":"CUTEst.csjprod","text":"csjprod(T, libsif, status, n, m, gotj, jtrans, x, nnz_vector, index_nz_vector, vector, lvector, nnz_result, index_nz_result, result, lresult)\n\nThe csjprod subroutine forms the product of a sparse vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:          [OUT] Vector{Cint}\nn:               [IN]  Vector{Cint}\nm:               [IN]  Vector{Cint}\ngotj:            [IN]  Vector{Bool}\njtrans:          [IN]  Vector{Bool}\nx:               [IN]  Vector{T}\nnnz_vector:      [IN]  Vector{Cint}\nindexnzvector: [IN]  Vector{Cint}\nvector:          [IN]  Vector{T}\nlvector:         [IN]  Vector{Cint}\nnnz_result:      [OUT] Vector{Cint}\nindexnzresult: [OUT] Vector{Cint}\nresult:          [OUT] Vector{T}\nlresult:         [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cgrdh","page":"Using CUTEst core functions","title":"CUTEst.cgrdh","text":"cgrdh(T, libsif, status, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val, lh1, h_val)\n\nThe cgrdh subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients and matrices are stored in a dense format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\ngrlagf:  [IN]  Vector{Bool}\ng:       [OUT] Vector{T}\njtrans:  [IN]  Vector{Bool}\nlj1:     [IN]  Vector{Cint}\nlj2:     [IN]  Vector{Cint}\nj_val:   [OUT] Matrix{T}\nlh1:     [IN]  Vector{Cint}\nh_val:   [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdh","page":"Using CUTEst core functions","title":"CUTEst.cdh","text":"cdh(T, libsif, status, n, m, x, y, lh1, h_val)\n\nThe cdh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nlh1:     [IN]  Vector{Cint}\nh_val:   [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ush","page":"Using CUTEst core functions","title":"CUTEst.ush","text":"ush(T, libsif, status, n, x, nnzh, lh, h_val, h_row, h_col)\n\nThe ush subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csh","page":"Using CUTEst core functions","title":"CUTEst.csh","text":"csh(T, libsif, status, n, m, x, y, nnzh, lh, h_val, h_row, h_col)\n\nThe csh subroutine evaluates the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ueh","page":"Using CUTEst core functions","title":"CUTEst.ueh","text":"ueh(T, libsif, status, n, x, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)\n\nThe ueh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:     [OUT] Vector{Cint}\nn:          [IN]  Vector{Cint}\nx:          [IN]  Vector{T}\nne:         [OUT] Vector{Cint}\nlhe_ptr:    [IN]  Vector{Cint}\nherowptr: [OUT] Vector{Cint}\nhevalptr: [OUT] Vector{Cint}\nlhe_row:    [IN]  Vector{Cint}\nhe_row:     [OUT] Vector{Cint}\nlhe_val:    [IN]  Vector{Cint}\nhe_val:     [OUT] Vector{T}\nbyrows:     [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cchprods","page":"Using CUTEst core functions","title":"CUTEst.cchprods","text":"cchprods(T, libsif, status, n, m, goth, x, vector, lchp, chp_val, chp_ind, chp_ptr)\n\nThe cchprods subroutine forms the product of a vector with each of the Hessian matrix of the constraint functions c(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point x= X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\ngoth:    [IN]  Vector{Bool}\nx:       [IN]  Vector{T}\nvector:  [IN]  Vector{T}\nlchp:    [IN]  Vector{Cint}\nchp_val: [OUT] Vector{T}\nchp_ind: [IN]  Vector{Cint}\nchp_ptr: [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ccifsg","page":"Using CUTEst core functions","title":"CUTEst.ccifsg","text":"ccifsg(T, libsif, status, n, icon, x, ci, nnzgci, lgci, gci_val, gci_var, grad)\n\nThe ccifsg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The gradient is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nicon:    [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nci:      [OUT] Vector{T}\nnnzgci:  [OUT] Vector{Cint}\nlgci:    [IN]  Vector{Cint}\ngci_val: [OUT] Vector{T}\ngci_var: [OUT] Vector{Cint}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.uofg","page":"Using CUTEst core functions","title":"CUTEst.uofg","text":"uofg(T, libsif, status, n, x, f, g, grad)\n\nThe uofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\ng:       [OUT] Vector{T}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.connames","page":"Using CUTEst core functions","title":"CUTEst.connames","text":"connames(T, libsif, status, m, cname)\n\nThe connames subroutine obtains the names of the general constraints of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nm:       [IN]  Vector{Cint}\ncname:   [OUT] Vector{Cchar}\n\nTo get useful names, use String(cname[:,i]).\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cisgr","page":"Using CUTEst core functions","title":"CUTEst.cisgr","text":"cisgr(T, libsif, status, n, iprod, x, nnzg, lg, g_val, g_var)\n\nThe cisgr subroutine evaluates the gradient of either the objective function or a constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case. The gradient is stored in sparse format.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\niprob:   [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nnnzg:    [OUT] Vector{Cint}\nlg:      [IN]  Vector{Cint}\ng_val:   [OUT] Vector{T}\ng_var:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.udh","page":"Using CUTEst core functions","title":"CUTEst.udh","text":"udh(T, libsif, status, n, x, lh1, h)\n\nThe udh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nlh1:     [IN]  Vector{Cint}\nh:       [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdimse","page":"Using CUTEst core functions","title":"CUTEst.cdimse","text":"cdimse(T, libsif, status, ne, he_val_ne, he_row_ne)\n\nThe cdimse subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded from a SIF file by the script sifdecoder. The matrix is stored in sparse \"finite element\" format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:    [OUT] Vector{Cint}\nne:        [OUT] Vector{Cint}\nhevalne: [OUT] Vector{Cint}\nherowne: [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ushp","page":"Using CUTEst core functions","title":"CUTEst.ushp","text":"ushp(T, libsif, status, n, nnzh, lh, h_row, h_col)\n\nThe ushp subroutine evaluates the sparsity pattern of the Hessian matrix of the objective function of the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.creport","page":"Using CUTEst core functions","title":"CUTEst.creport","text":"creport(T, libsif, status, calls, time)\n\nThe creport subroutine obtains statistics concerning function evaluation and CPU time used for constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\ncalls:   [OUT] Vector{T}\ntime:    [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cshp","page":"Using CUTEst core functions","title":"CUTEst.cshp","text":"cshp(T, libsif, status, n, nnzh, lh, h_row, h_col)\n\nThe cshp subroutine evaluates the sparsity pattern of the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.probname","page":"Using CUTEst core functions","title":"CUTEst.probname","text":"probname(T, libsif, status, pname)\n\nThe probname subroutine obtains the name of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\npname:   [OUT] Vector{Cchar}\n\nTo get a useful name, use String(pname).\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.unames","page":"Using CUTEst core functions","title":"CUTEst.unames","text":"unames(T, libsif, status, n, pname, vname)\n\nThe unames subroutine obtains the names of the problem and its variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\npname:   [OUT] Vector{Cchar}\nvname:   [OUT] Vector{Cchar}\n\nTo get useful names, use String(x) where x can be pname or vname[:,i].\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cidh","page":"Using CUTEst core functions","title":"CUTEst.cidh","text":"cidh(T, libsif, status, n, x, iprob, lh1, h)\n\nThe cidh subroutine evaluates the Hessian matrix of either the objective function or a constraint function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\niprob:   [IN]  Vector{Cint}\nlh1:     [IN]  Vector{Cint}\nh:       [OUT] Matrix{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csgr","page":"Using CUTEst core functions","title":"CUTEst.csgr","text":"csgr(T, libsif, status, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun)\n\nThe csgr subroutine evaluates the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients are stored in a sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\ngrlagf:  [IN]  Vector{Bool}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\nj_val:   [OUT] Vector{T}\nj_var:   [OUT] Vector{Cint}\nj_fun:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.usetup","page":"Using CUTEst core functions","title":"CUTEst.usetup","text":"usetup(T, libsif, status, input, out, io_buffer, n, x, x_l, x_u)\n\nThe usetup subroutine sets up the correct data structures for subsequent computations in the case where the only possible constraints are bound constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:    [OUT] Vector{Cint}\ninput:     [IN]  Vector{Cint}\nout:       [IN]  Vector{Cint}\nio_buffer: [IN]  Vector{Cint}\nn:         [IN]  Vector{Cint}\nx:         [OUT] Vector{T}\nx_l:       [OUT] Vector{T}\nx_u:       [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csgrsh","page":"Using CUTEst core functions","title":"CUTEst.csgrsh","text":"csgrsh(T, libsif, status, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, nnzh, lh, h_val, h_row, h_col)\n\nThe csgrsh subroutine evaluates the gradients of the general constraints, the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) and the gradient of either the objective function or the Lagrangian corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The data is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\ngrlagf:  [IN]  Vector{Bool}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\nj_val:   [OUT] Vector{T}\nj_var:   [OUT] Vector{Cint}\nj_fun:   [OUT] Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cdimen","page":"Using CUTEst core functions","title":"CUTEst.cdimen","text":"cdimen(T, libsif, status, input, n, m)\n\nThe cdimen subroutine discovers how many variables and constraints are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\ninput:   [IN]  Vector{Cint}\nn:       [OUT] Vector{Cint}\nm:       [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cshprod","page":"Using CUTEst core functions","title":"CUTEst.cshprod","text":"cshprod(T, libsif, status, n, m, goth, x, y, nnz_vector, index_nz_vector, vector, nnz_result, index_nz_result, result)\n\nThe cshprod subroutine forms the product of a sparse vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:          [OUT] Vector{Cint}\nn:               [IN]  Vector{Cint}\nm:               [IN]  Vector{Cint}\ngoth:            [IN]  Vector{Cint}\nx:               [IN]  Vector{T}\ny:               [IN]  Vector{T}\nnnz_vector:      [IN]  Vector{Cint}\nindexnzvector: [IN]  Vector{Cint}\nvector:          [IN]  Vector{T}\nnnz_result:      [OUT] Vector{Cint}\nindexnzresult: [OUT] Vector{Cint}\nresult:          [OUT] Vector{T}\n\nNotice that vector and result should have allocated dimension of n.\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cchprodsp","page":"Using CUTEst core functions","title":"CUTEst.cchprodsp","text":"cchprodsp(T, libsif, status, m, lchp, chp_ind, chp_ptr)\n\nThe cchprodsp subroutine obtains the sparsity structure used when forming the product of a vector with each of the Hessian matrices of the constraint functions c(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point x= X.\n\nstatus:  [OUT] Vector{Cint}\nm:       [IN]  Vector{Cint}\nlchp:    [IN]  Vector{Cint}\nchp_ind: [IN]  Vector{Cint}\nchp_ptr: [IN]  Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cconst","page":"Using CUTEst core functions","title":"CUTEst.cconst","text":"cconst(T, libsif, status, m, c)\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.udimen","page":"Using CUTEst core functions","title":"CUTEst.udimen","text":"udimen(T, libsif, status, input, n)\n\nThe udimen subroutine discovers how many variables are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\ninput:   [IN]  Vector{Cint}\nn:       [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.pname","page":"Using CUTEst core functions","title":"CUTEst.pname","text":"pname(T, libsif, status, input, pname)\n\nThe pname subroutine obtains the name of the problem directly from the datafile OUTSDIF.d that was created by the script sifdecoder when decoding a SIF file. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\ninput:   [IN]  Vector{Cint}\npname:   [OUT] Vector{Cchar}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.chprod","page":"Using CUTEst core functions","title":"CUTEst.chprod","text":"chprod(T, libsif, status, n, m, goth, x, y, vector, result)\n\nThe chprod subroutine forms the product of a vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\ngoth:    [IN]  Vector{Bool}\nx:       [IN]  Vector{T}\ny:       [IN]  Vector{T}\nvector:  [IN]  Vector{T}\nresult:  [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cterminate","page":"Using CUTEst core functions","title":"CUTEst.cterminate","text":"cterminate(T, libsif, status)\n\nThe uterminate subroutine deallocates all workspace arrays created since the last call to csetup.\n\nstatus:  [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cifn","page":"Using CUTEst core functions","title":"CUTEst.cifn","text":"cifn(T, libsif, status, n, iprob, x, f)\n\nThe cifn subroutine evaluates the value of either the objective function or a constrainted function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\niprob:   [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nf:       [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cstats","page":"Using CUTEst core functions","title":"CUTEst.cstats","text":"cstats(T, libsif, status, nonlinear_variables_objective, nonlinear_variables_constraints, equality_constraints, linear_constraints)\n\nstatus:                          [OUT] Vector{Cint}\nnonlinearvariablesobjective:   [OUT] Vector{Cint}\nnonlinearvariablesconstraints: [OUT] Vector{Cint}\nequality_constraints:            [OUT] Vector{Cint}\nlinear_constraints:              [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.cnames","page":"Using CUTEst core functions","title":"CUTEst.cnames","text":"cnames(T, libsif, status, n, m, pname, vname, cname)\n\nThe cnames subroutine obtains the names of the problem, its variables and general constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\npname:   [OUT] Vector{Cchar}\nvname:   [OUT] Vector{Cchar}\ncname:   [OUT] Vector{Cchar}\n\nTo get useful names, use String(x) where x can be pname, vname[:,i], or cname[:,i].\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ugrsh","page":"Using CUTEst core functions","title":"CUTEst.ugrsh","text":"ugrsh(T, libsif, status, n, x, g, nnzh, lh, h_val, h_row, h_col)\n\nThe ugrsh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\ng:       [OUT] Vector{T}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_val:   [OUT] Vector{T}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.varnames","page":"Using CUTEst core functions","title":"CUTEst.varnames","text":"varnames(T, libsif, status, n, vname)\n\nThe varnames subroutine obtains the names of the problem variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nvname:   [OUT] Vector{Cchar}\n\nTo get useful names, use String(vname[:, i]).\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.uvartype","page":"Using CUTEst core functions","title":"CUTEst.uvartype","text":"uvartype(T, libsif, status, n, x_type)\n\nThe uvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nx_type:  [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.fopen","page":"Using CUTEst core functions","title":"CUTEst.fopen","text":"fopen(T, libsif, funit, outsdif, status)\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.csgrshp","page":"Using CUTEst core functions","title":"CUTEst.csgrshp","text":"csgrshp(T, libsif, status, n, nnzj, lj, j_var, j_fun, nnzh, lh, h_row, h_col)\n\nThe csgrshp subroutine evaluates sparsity pattern used when storing the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x), as well as the Hessian of the Lagrangian function, corresponding to the problem decoded from a SIF file by the script sifdecoder.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\nj_var:   [OUT] Vector{Cint}\nj_fun:   [OUT] Vector{Cint}\nnnzh:    [OUT] Vector{Cint}\nlh:      [IN]  Vector{Cint}\nh_row:   [OUT] Vector{Cint}\nh_col:   [OUT] Vector{Cint}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.ccfsg","page":"Using CUTEst core functions","title":"CUTEst.ccfsg","text":"ccfsg(T, libsif, status, n, m, x, c, nnzj, lj, j_val, j_var, j_fun, grad)\n\nThe ccfsg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients in the constrained minimization case. The gradients are stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.\n\nstatus:  [OUT] Vector{Cint}\nn:       [IN]  Vector{Cint}\nm:       [IN]  Vector{Cint}\nx:       [IN]  Vector{T}\nc:       [OUT] Vector{T}\nnnzj:    [OUT] Vector{Cint}\nlj:      [IN]  Vector{Cint}\nj_val:   [OUT] Vector{T}\nj_var:   [OUT] Vector{Cint}\nj_fun:   [OUT] Vector{Cint}\ngrad:    [IN]  Vector{Bool}\n\n\n\n\n\n","category":"function"},{"location":"core/#CUTEst.classification","page":"Using CUTEst core functions","title":"CUTEst.classification","text":"classification(T, libsif, status, funit, class)\n\n\n\n\n\n","category":"function"},{"location":"model/","page":"CUTEstModel","title":"CUTEstModel","text":"The main goal of CUTEst.jl is to create a CUTEstModel, which rely on the API provided by NLPModels.jl.","category":"page"},{"location":"model/#CUTEst.CUTEstModel","page":"CUTEstModel","title":"CUTEst.CUTEstModel","text":"CUTEstModel{T}(name, args...; kwargs...)\nCUTEstModel(name, args...; precision::Symbol=:double, decode::Bool=true,\n            verbose::Bool=false, efirst::Bool=true, lfirst::Bool=true, lvfirst::Bool=true)\n\nCreates a CUTEstModel following the API of NLPModels.jl. This model must be finalized before creating a new one with the same name and precision T. Finalize the current model by calling finalize(nlp) to avoid conflicts.\n\nArguments\n\nname::AbstractString: The name of the SIF problem to load.\nargs...: Additional arguments passed directly to sifdecoder. These can be used to change parameters of the model.\n\nKeyword arguments\n\nprecision::Symbol: Specifies the precision of the CUTEstModel. Options are :single, :double (default), or :quadruple. This keyword argument is not supported when using a constructor with a data type T.\ndecode::Bool: Whether to call sifdecoder. Defaults to true.\nverbose::Bool: If true, enables verbose output during the decoding process. Passed to sifdecoder.\nefirst::Bool: If true, places equality constraints first.\nlfirst::Bool: If true, places linear (or affine) constraints first.\nlvfirst::Bool: If true, places nonlinear variables first.\n\nwarning: Warning\nThe second constructor based on the keyword argument precision is type-unstable.\n\nCoexistance of multiple CUTEst models\n\nEach CUTEstModel is, in theory, independent, and we can create as many models as we want : \n\nall CUTEstModel instances are based on different problems\nall CUTEstModel instances are based on the same problem but with different precisions\n\nwarning: Warning\nIf we have CUTEstModel instances for the same problem and precision, but with variable parameters (such as size), we encounter an issue due to the shared library generated after decoding the problem, suffixed only with the name of the problem and its precision.\n\nExamples\n\nusing CUTEst\n\n# Create a CUTEstModel with the name \"CHAIN\" and a parameter adjustment\nnlp = CUTEstModel{Float64}(\"CHAIN\", \"-param\", \"NH=50\")\ndisplay(nlp)\nfinalize(nlp)  # Finalize the current model\n\n# Create another CUTEstModel with different parameters\nnlp = CUTEstModel{Float64}(\"CHAIN\", \"-param\", \"NH=100\")\ndisplay(nlp)\nfinalize(nlp)  # Finalize the new model\n\n\n\n\n\n","category":"type"},{"location":"classification/#CUTEst.select_sif_problems","page":"Classification of SIF problems","title":"CUTEst.select_sif_problems","text":"select_sif_problems(; min_var=1, max_var=Inf, min_con=0, max_con=Inf,\n                      objtype=*, contype=*, only_free_var=false,\n                      only_bnd_var=false, only_linear_con=false,\n                      only_nonlinear_con=false, only_equ_con=false,\n                      only_ineq_con=false, custom_filter=*)\n\nReturns a subset of the CUTEst problems using the classification file classf.json.\n\nKeyword arguments\n\nmin_var and max_var: set lower and upper bounds on the number of variables.\nmin_con and max_con: set lower and upper bounds on the number of linear or nonlinear constraints (excluding simple bounds on variables).   ⚠ max_con=0 means: keep only problems with no nonlinear or linear constraints;   variable bounds are not counted as constraints here, so bound-constrained problems will still be included.\nonly_* flags: mutually exclusive filters to select problems with only:\nfree variables (only_free_var=true)\nbounded variables (only_bnd_var=true)\nlinear constraints (only_linear_con=true)\nnonlinear constraints (only_nonlinear_con=true)\nequality constraints (only_equ_con=true)\ninequality constraints (only_ineq_con=true)\nThese can all be false, but at most one can be true.\nobjtype: filter by type of objective function, following the MASTSIF classification.   Accepts a number, symbol, string, or an array of these:\n1, :none or \"none\": no objective function\n2, :constant or \"constant\"\n3, :linear or \"linear\"\n4, :quadratic or \"quadratic\"\n5, :sum_of_squares or \"sum_of_squares\"\n6, :other or \"other\"\ncontype: filter by type of constraints, also from MASTSIF:\n1, :unc or \"unc\": truly unconstrained — no linear/nonlinear constraints and no variable bounds\n2, :fixed_vars or \"fixed_vars\": only fixed variables\n3, :bounds or \"bounds\": only variable bounds\n4, :network or \"network\"\n5, :linear or \"linear\": linear constraints\n6, :quadratic or \"quadratic\"\n7, :other or \"other\"\n\n⚠ Important difference:\n\nmax_con=0 keeps problems that may still have variable bounds (i.e., bound-constrained).\ncontype=\"unc\" keeps only problems that have no constraints at all (no nonlinear constraints, no linear constraints, and no bounds).\n\nIf you want to filter by truly unconstrained problems after selection, use: ```julia filter(p -> istrulyunconstrained(p), selectsifproblems())\n\ncustom_filter: a function for additional filtering. Receives a dictionary with metadata, for example:\n\n    \"objtype\": \"none\", \"constant\", \"linear\", \"quadratic\", \"sum_of_squares\", \"other\"\n\n    \"contype\": \"unc\", \"fixed_vars\", \"bounds\", \"network\", \"linear\", \"quadratic\", \"other\"\n\n    \"regular\": Bool\n\n    \"derivative_order\": Int\n\n    \"origin\": \"academic\", \"modelling\", \"real\"\n\n    \"has_interval_var\": Bool\n\n    \"variables\": number and types of variables (\"number\", \"fixed\", \"free\", etc.)\n\n    \"constraints\": number and types of constraints (\"number\", \"linear\", \"nonlinear\", etc.)\n\nExamples\n\nProblems with 10–100 variables and only linear constraints\n\nfiltered1 = selectsifproblems(; minvar=10, maxvar=100, onlylinearcon=true)\n\nProblems without nonlinear or linear constraints (may still have bounds)\n\nfiltered2 = selectsifproblems(; max_con=0)\n\nProblems that are truly unconstrained: no constraints and no variable bounds\n\nfiltered3 = filter(istrulyunconstrained, selectsifproblems())\n\nProblems with at least one constraint\n\nfiltered4 = selectsifproblems(; min_con=1)\n\n\n\n\n\n","category":"function"},{"location":"classification/#CUTEst.build_classification","page":"Classification of SIF problems","title":"CUTEst.build_classification","text":"build_classification()\n\nCreates the file classf.json, running each problem in CLASSF.DB and extracting the necessary information. It should be left alone, unless you think it is not updated. If you do, please open an issue.\n\n\n\n\n\n","category":"function"},{"location":"classification/#CUTEst.generator_sif_problems","page":"Classification of SIF problems","title":"CUTEst.generator_sif_problems","text":"generator_sif_problems(; libsif_folder=libsif_path, filter=name -> true)\n\nReturn a generator of problem names in the libsif_folder satisfying the filter predicate.\n\nArguments\n\nlibsif_folder: Directory to look for SIF files (default: libsif_path).\nfilter: Function to filter problem names (default: include all, name -> true).\n\nReturns\n\nA generator of problem names (without .SIF extension) that satisfy the filter.\n\nExample\n\nfor name in generator_sif_problems()\n    println(name)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#CUTEst.cons_coord","page":"Reference","title":"CUTEst.cons_coord","text":"cons_coord(nlp, x)\n\nComputes the constraint vector and the Jacobian in coordinate format. Usage:\n\nc, jrow, jcol, jval = cons_coord(nlp, x)\n\nnlp:  [IN] CUTEstModel\nx:    [IN] Vector{T}\nc:    [OUT] Vector{T}\njrow: [OUT] Vector{Cint}\njcol: [OUT] Vector{Cint}\njval: [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"reference/#CUTEst.cons_coord!","page":"Reference","title":"CUTEst.cons_coord!","text":"cons_coord!(nlp, x, c, rows, cols, vals)\n\nComputes the constraint vector and the Jacobian in coordinate format. Usage:\n\ncons_coord!(nlp, x, c, rows, cols, vals)\n\nnlp:  [IN] CUTEstModel\nx:    [IN] Vector{T}\nc:    [OUT] Vector{T}\njrow: [OUT] Vector{Cint}\njcol: [OUT] Vector{Cint}\njval: [OUT] Vector{T}\n\n\n\n\n\n","category":"function"},{"location":"reference/#CUTEst.consjac","page":"Reference","title":"CUTEst.consjac","text":"consjac(nlp, x)\n\nComputes the constraint vector and the Jacobian in internal sparse format. Usage:\n\nc, J = consjac(nlp, x)\n\nnlp:  [IN] CUTEstModel\nx:    [IN] Vector{T}\nc:    [OUT] Vector{T}\nJ:    [OUT] Base.SparseMatrix.SparseMatrixCSC{T,Cint}\n\n\n\n\n\n","category":"function"},{"location":"#CUTEst.jl-documentation","page":"Home","title":"CUTEst.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides an interface to CUTEst, the Constrained and Unconstrained Testing Environment with safe threads for nonlinear optimization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package uses NLPModels.jl, but it also provides direct access to the CUTEst functions.","category":"page"},{"location":"#CUTEst-brief-history","page":"Home","title":"CUTEst brief history","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CUTEst has been around for a while. It started as CUTE, then evolved into CUTEr, CUTEr2, and finally CUTEst. The original project can be used independently of Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CUTEst works by decoding a .SIF file into other files and objects so that a user can compile and link them to their code. It also offers the option to perform these steps for you, in which case you need to send some code to its folder and request the compilation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CUTEst provides about 100 methods to access the objective and constraint functions, as well as their derivatives in many different formats. It also offers access to the problem's information, such as the number of variables, constraints, the initial point, bounds, and so on.","category":"page"},{"location":"#Prerequisites","page":"Home","title":"Prerequisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On all platforms except Windows, you'll need to install gfortran. On Windows, everything is installed for you thanks to Julia artifacts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On Ubuntu, you can do this with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo apt-get install gfortran","category":"page"},{"location":"","page":"Home","title":"Home","text":"On Arch Linux, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo pacman -S gfortran","category":"page"},{"location":"","page":"Home","title":"Home","text":"On macOS, use Homebrew:","category":"page"},{"location":"","page":"Home","title":"Home","text":"brew install gfortran","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following command should automatically download and install CUTEst and its dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add CUTEst","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can check an Introduction to CUTEst.jl on our site.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The simplest way to use CUTEst is through the interface provided by NLPModels.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CUTEst, NLPModels\n\nnlp = CUTEstModel{Float64}(\"ROSENBR\")\nprintln(\"x0 = $(nlp.meta.x0)\")\nprintln(\"fx = $( obj(nlp, nlp.meta.x0) )\")\nprintln(\"gx = $( grad(nlp, nlp.meta.x0) )\")\nprintln(\"Hx = $( hess(nlp, nlp.meta.x0) )\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check the NLPModels API for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can pass parameters to sifdecoder by providing additional arguments to CUTEstModel. For instance, to change NH for the model CHAIN, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CUTEst\n\nfor nh in 50:50:200\n  nlp = CUTEstModel{Float64}(\"CHAIN\", \"-param\", \"NH=$nh\")\n  println(\"nh = $nh, nnzh = $(nlp.meta.nnzh)\")\n  finalize(nlp)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each call to CUTEstModel creates an independent model. You do not need to call finalize(nlp) manually: the finalizer in CUTEst.jl handles unloading the shared library automatically when the model is garbage-collected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"The finalizer is automatic, but when creating multiple models with the same problem name in the same process, you must finalize explicitly to avoid conflicts.","category":"page"},{"location":"#Working-with-CUTEst-directly","page":"Home","title":"Working with CUTEst directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have also implemented functions to allow direct access to CUTEst functions through a core API, which serves as a wrapper for CUTEst. For more information, see the section on the core interface.","category":"page"}]
}
