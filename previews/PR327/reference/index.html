<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · CUTEst.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="CUTEst.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">CUTEst.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../core/">Core</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CUTEst.CUTEstModel-Tuple{AbstractString, Vararg{Any}}"><code>CUTEst.CUTEstModel</code></a></li><li><a href="#CUTEst.ccfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccfg</code></a></li><li><a href="#CUTEst.ccfsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccfsg</code></a></li><li><a href="#CUTEst.cchprods-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cchprods</code></a></li><li><a href="#CUTEst.cchprodsp-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cchprodsp</code></a></li><li><a href="#CUTEst.ccifg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccifg</code></a></li><li><a href="#CUTEst.ccifsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccifsg</code></a></li><li><a href="#CUTEst.cdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cdh</code></a></li><li><a href="#CUTEst.cdhc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cdhc</code></a></li><li><a href="#CUTEst.cdimchp-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimchp</code></a></li><li><a href="#CUTEst.cdimen-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimen</code></a></li><li><a href="#CUTEst.cdimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimse</code></a></li><li><a href="#CUTEst.cdimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimsh</code></a></li><li><a href="#CUTEst.cdimsj-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimsj</code></a></li><li><a href="#CUTEst.ceh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ceh</code></a></li><li><a href="#CUTEst.cfn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cfn</code></a></li><li><a href="#CUTEst.cgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cgr</code></a></li><li><a href="#CUTEst.cgrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cgrdh</code></a></li><li><a href="#CUTEst.chcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}"><code>CUTEst.chcprod</code></a></li><li><a href="#CUTEst.chprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}"><code>CUTEst.chprod</code></a></li><li><a href="#CUTEst.cidh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cidh</code></a></li><li><a href="#CUTEst.cifn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cifn</code></a></li><li><a href="#CUTEst.cigr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cigr</code></a></li><li><a href="#CUTEst.cisgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cisgr</code></a></li><li><a href="#CUTEst.cish-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cish</code></a></li><li><a href="#CUTEst.cjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cjprod</code></a></li><li><a href="#CUTEst.clfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.clfg</code></a></li><li><a href="#CUTEst.cnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}, Matrix{UInt8}}"><code>CUTEst.cnames</code></a></li><li><a href="#CUTEst.cofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cofg</code></a></li><li><a href="#CUTEst.cofsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cofsg</code></a></li><li><a href="#CUTEst.connames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}"><code>CUTEst.connames</code></a></li><li><a href="#CUTEst.cons_coord-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cons_coord</code></a></li><li><a href="#CUTEst.cons_coord!-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cons_coord!</code></a></li><li><a href="#CUTEst.consjac-Tuple{CUTEstModel, AbstractVector}"><code>CUTEst.consjac</code></a></li><li><a href="#CUTEst.create_class-Tuple{}"><code>CUTEst.create_class</code></a></li><li><a href="#CUTEst.creport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.creport</code></a></li><li><a href="#CUTEst.csetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Vararg{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, 5}}"><code>CUTEst.csetup</code></a></li><li><a href="#CUTEst.csgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgr</code></a></li><li><a href="#CUTEst.csgreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgreh</code></a></li><li><a href="#CUTEst.csgrp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrp</code></a></li><li><a href="#CUTEst.csgrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrsh</code></a></li><li><a href="#CUTEst.csgrshp-NTuple{10, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrshp</code></a></li><li><a href="#CUTEst.csh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csh</code></a></li><li><a href="#CUTEst.cshc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cshc</code></a></li><li><a href="#CUTEst.cshcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cshcprod</code></a></li><li><a href="#CUTEst.cshp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cshp</code></a></li><li><a href="#CUTEst.cshprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cshprod</code></a></li><li><a href="#CUTEst.csjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csjprod</code></a></li><li><a href="#CUTEst.cstats-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cstats</code></a></li><li><a href="#CUTEst.cterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cterminate</code></a></li><li><a href="#CUTEst.cvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cvartype</code></a></li><li><a href="#CUTEst.pname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}"><code>CUTEst.pname</code></a></li><li><a href="#CUTEst.probname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}"><code>CUTEst.probname</code></a></li><li><a href="#CUTEst.select-Tuple{}"><code>CUTEst.select</code></a></li><li><a href="#CUTEst.set_mastsif-Tuple{}"><code>CUTEst.set_mastsif</code></a></li><li><a href="#CUTEst.sifdecoder-Tuple{AbstractString, Vararg{Any}}"><code>CUTEst.sifdecoder</code></a></li><li><a href="#CUTEst.ubandh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ubandh</code></a></li><li><a href="#CUTEst.udh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.udh</code></a></li><li><a href="#CUTEst.udimen-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimen</code></a></li><li><a href="#CUTEst.udimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimse</code></a></li><li><a href="#CUTEst.udimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimsh</code></a></li><li><a href="#CUTEst.ueh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ueh</code></a></li><li><a href="#CUTEst.ufn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ufn</code></a></li><li><a href="#CUTEst.ugr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ugr</code></a></li><li><a href="#CUTEst.ugrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.ugrdh</code></a></li><li><a href="#CUTEst.ugreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ugreh</code></a></li><li><a href="#CUTEst.ugrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ugrsh</code></a></li><li><a href="#CUTEst.uhprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.uhprod</code></a></li><li><a href="#CUTEst.unames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}}"><code>CUTEst.unames</code></a></li><li><a href="#CUTEst.uofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uofg</code></a></li><li><a href="#CUTEst.ureport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ureport</code></a></li><li><a href="#CUTEst.usetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.usetup</code></a></li><li><a href="#CUTEst.ush-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ush</code></a></li><li><a href="#CUTEst.ushp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ushp</code></a></li><li><a href="#CUTEst.ushprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ushprod</code></a></li><li><a href="#CUTEst.uterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uterminate</code></a></li><li><a href="#CUTEst.uvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uvartype</code></a></li><li><a href="#CUTEst.varnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}"><code>CUTEst.varnames</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CUTEst.CUTEstModel-Tuple{AbstractString, Vararg{Any}}" href="#CUTEst.CUTEstModel-Tuple{AbstractString, Vararg{Any}}"><code>CUTEst.CUTEstModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nlp = CUTEstModel(name, args...; kwargs...)</code></pre><p>Creates a CUTEst model following the NLPModels API. This model needs to be finalized before a new one is created (e.g., calling <code>finalize(nlp)</code>).</p><p><strong>Optional arguments</strong></p><p>Any extra arguments will be passed to <code>sifdecoder</code>. You can, for instance, change parameters of the model:</p><pre><code class="language-julia hljs">using CUTEst

nlp = CUTEstModel(&quot;CHAIN&quot;, &quot;-param&quot;, &quot;NH=50&quot;)
println(nlp.meta.nnzh)
finalize(nlp)
nlp = CUTEstModel(&quot;CHAIN&quot;, &quot;-param&quot;, &quot;NH=100&quot;)
println(nlp.meta.nnzh)
finalize(nlp)

# output

153
303</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>decode::Bool = true</code>: Whether to call sifdecoder.</li><li><code>verbose::Bool = false</code>: Passed to sifdecoder.</li><li><code>efirst</code>::Bool = true`: Equalities first?</li><li><code>lfirst</code>::Bool = true`: Linear (or affine) constraints first?</li><li><code>lvfirst::Bool = true</code>: Nonlinear variables should appear first?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/CUTEst.jl#L229-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ccfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ccfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccfg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ccfg</strong></p><p>The ccfg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ccfg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ccfg(io_err, n, m, x, c, jtrans, lcjac1, lcjac2, cjac, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>c:       [OUT] Vector{Cdouble}</li><li>jtrans:  [IN] Vector{Cint}</li><li>lcjac1:  [IN] Vector{Cint}</li><li>lcjac2:  [IN] Vector{Cint}</li><li>cjac:    [OUT] Array{Cdouble, 2}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1723-L1752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ccfsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ccfsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccfsg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ccfsg</strong></p><p>The ccfsg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients in the constrained minimization case. The gradients are stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ccfsg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ccfsg(io_err, n, m, x, c, nnzj, lj, j_val, j_var, j_fun, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>c:       [OUT] Vector{Cdouble}</li><li>nnzj:    [OUT] Vector{Cint}</li><li>lj:      [IN] Vector{Cint}</li><li>j_val:   [OUT] Vector{Cdouble}</li><li>j_var:   [OUT] Vector{Cint}</li><li>j_fun:   [OUT] Vector{Cint}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2003-L2034">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cchprods-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cchprods-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cchprods</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cchprods</strong></p><p>The cchprods subroutine forms the product of a vector with each of the Hessian matrix of the constraint functions c(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point x= X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cchprods</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cchprods(io_err, n, m, goth, x, vector, lchp, chp_val, chp_ind, chp_ptr)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>goth:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>vector:  [IN] Vector{Cdouble}</li><li>lchp:    [IN] Vector{Cint}</li><li>chp_val: [OUT] Vector{Cdouble}</li><li>chp_ind: [IN] Vector{Cint}</li><li>chp_ptr: [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3425-L3455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cchprodsp-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cchprodsp-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cchprodsp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cchprodsp</strong></p><p>The cchprodsp subroutine obtains the sparsity structure used when forming the product of a vector with each of the Hessian matrices of the constraint functions c(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point x= X.</p><p>Usage:</p><pre><code class="nohighlight hljs">cchprodsp(io_err, m, lchp, chp_ind, chp_ptr)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>lchp:    [IN] Vector{Cint}</li><li>chp_ind: [IN] Vector{Cint}</li><li>chp_ptr: [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3495-L3511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ccifg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ccifg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccifg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ccifg</strong></p><p>The ccifg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ccifg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ccifg(io_err, n, icon, x, ci, gci, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>icon:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>ci:      [OUT] Vector{Cdouble}</li><li>gci:     [OUT] Vector{Cdouble}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2077-L2104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ccifsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ccifsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ccifsg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ccifsg</strong></p><p>The ccifsg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The gradient is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ccifsg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ccifsg(io_err, n, icon, x, ci, nnzgci, lgci, gci_val, gci_var, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>icon:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>ci:      [OUT] Vector{Cdouble}</li><li>nnzgci:  [OUT] Vector{Cint}</li><li>lgci:    [IN] Vector{Cint}</li><li>gci_val: [OUT] Vector{Cdouble}</li><li>gci_var: [OUT] Vector{Cint}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2127-L2158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.cdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cdh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdh</strong></p><p>The cdh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdh(io_err, n, m, x, y, lh1, h_val)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>lh1:     [IN] Vector{Cint}</li><li>h_val:   [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2282-L2309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdhc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.cdhc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cdhc</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdhc</strong></p><p>The cdhc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdhc</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdhc(io_err, n, m, x, y, lh1, h_val)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>lh1:     [IN] Vector{Cint}</li><li>h_val:   [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2332-L2359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdimchp-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cdimchp-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimchp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdimchp</strong></p><p>The cdimchp subroutine determines the number of nonzero elements required to store the products of the Hessian matrices of the constraint functions with a specified vector for the problem decoded into OUTSDIF.d in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdimchp</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdimchp(io_err, nnzchp)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>nnzchp:  [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L529-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdimen-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cdimen-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdimen</strong></p><p>The cdimen subroutine discovers how many variables and constraints are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdimen</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdimen(io_err, input, n, m)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>input:   [IN] Vector{Cint}</li><li>n:       [OUT] Vector{Cint}</li><li>m:       [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L436-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cdimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimse</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdimse</strong></p><p>The cdimse subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded from a SIF file by the script sifdecoder. The matrix is stored in sparse &quot;finite element&quot; format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdimse</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdimse(io_err, ne, he_val_ne, he_row_ne)</code></pre><ul><li>io_err:    [OUT] Vector{Cint}</li><li>ne:        [OUT] Vector{Cint}</li><li>he<em>val</em>ne: [OUT] Vector{Cint}</li><li>he<em>row</em>ne: [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L555-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cdimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimsh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdimsh</strong></p><p>The cdimsh subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse &quot;coordinate&quot; format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdimsh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdimsh(io_err, nnzh)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L503-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cdimsj-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cdimsj-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cdimsj</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cdimsj</strong></p><p>The cdimsj subroutine determines the number of nonzero elements required to store the matrix of gradients of the objective function and constraint functions for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cdimsj</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cdimsj(io_err, nnzj)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>nnzj:    [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L476-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ceh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ceh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ceh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ceh</strong></p><p>The ceh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ceh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ceh(io_err, n, m, x, y, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row,</code></pre><p>he<em>row, lhe</em>val, he_val, byrows)</p><ul><li>io_err:     [OUT] Vector{Cint}</li><li>n:          [IN] Vector{Cint}</li><li>m:          [IN] Vector{Cint}</li><li>x:          [IN] Vector{Cdouble}</li><li>y:          [IN] Vector{Cdouble}</li><li>ne:         [OUT] Vector{Cint}</li><li>lhe_ptr:    [IN] Vector{Cint}</li><li>he<em>row</em>ptr: [OUT] Vector{Cint}</li><li>he<em>val</em>ptr: [OUT] Vector{Cint}</li><li>lhe_row:    [IN] Vector{Cint}</li><li>he_row:     [OUT] Vector{Cint}</li><li>lhe_val:    [IN] Vector{Cint}</li><li>he_val:     [OUT] Vector{Cdouble}</li><li>byrows:     [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2568-L2605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cfn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cfn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cfn</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cfn</strong></p><p>The cfn subroutine evaluates the value of the objective function and general constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cfn</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cfn(io_err, n, m, x, f, c)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li><li>c:       [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1566-L1591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.cgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cgr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cgr</strong></p><p>The cgr subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cgr</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cgr(io_err, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>grlagf:  [IN] Vector{Cint}</li><li>g:       [OUT] Vector{Cdouble}</li><li>jtrans:  [IN] Vector{Cint}</li><li>lj1:     [IN] Vector{Cint}</li><li>lj2:     [IN] Vector{Cint}</li><li>j_val:   [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1853-L1884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cgrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.cgrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cgrdh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cgrdh</strong></p><p>The cgrdh subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients and matrices are stored in a dense format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cgrdh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cgrdh(io_err, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val, lh1, h_val)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>grlagf:  [IN] Vector{Cint}</li><li>g:       [OUT] Vector{Cdouble}</li><li>jtrans:  [IN] Vector{Cint}</li><li>lj1:     [IN] Vector{Cint}</li><li>lj2:     [IN] Vector{Cint}</li><li>j_val:   [OUT] Array{Cdouble, 2}</li><li>lh1:     [IN] Vector{Cint}</li><li>h_val:   [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2198-L2233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.chcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}" href="#CUTEst.chcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}"><code>CUTEst.chcprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>chcprod</strong></p><p>The chcprod subroutine forms the product of a vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) of the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_chcprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">chcprod(io_err, n, m, goth, x, y, vector, result)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>goth:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>vector:  [IN] Vector{Cdouble}</li><li>result:  [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3127-L3155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.chprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}" href="#CUTEst.chprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Vararg{Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, 4}}"><code>CUTEst.chprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>chprod</strong></p><p>The chprod subroutine forms the product of a vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_chprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">chprod(io_err, n, m, goth, x, y, vector, result)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>goth:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>vector:  [IN] Vector{Cdouble}</li><li>result:  [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2984-L3012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cidh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.cidh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.cidh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cidh</strong></p><p>The cidh subroutine evaluates the Hessian matrix of either the objective function or a constraint function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cidh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cidh(io_err, n, x, iprob, lh1, h)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>iprob:   [IN] Vector{Cint}</li><li>lh1:     [IN] Vector{Cint}</li><li>h:       [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2657-L2683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cifn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cifn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cifn</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cifn</strong></p><p>The cifn subroutine evaluates the value of either the objective function or a constrainted function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cifn</code></pre><p>Usage:</p><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>iprob:   [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3566-L3585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cigr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cigr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cigr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cigr</strong></p><p>The cigr subroutine evaluates the gradient of either the objective function or a constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cigr</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>iprob:   [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>g_val:   [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3692-L3707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cisgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cisgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cisgr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cisgr</strong></p><p>The cisgr subroutine evaluates the gradient of either the objective function or a constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, in the constrained minimization case. The gradient is stored in sparse format.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cisgr</code></pre><p>Usage:</p><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>iprob:   [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>nnzg:    [OUT] Vector{Cint}</li><li>lg:      [IN] Vector{Cint}</li><li>g_val:   [OUT] Vector{Cdouble}</li><li>g_var:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3604-L3625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cish-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cish-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cish</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cish</strong></p><p>The cish subroutine evaluates the Hessian of a particular constraint function or the objective function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cish</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cish(io_err, n, x, iprob, nnzh, lh, h_val, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>iprob:   [IN] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2704-L2733">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cjprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cjprod</strong></p><p>The cjprod subroutine forms the product of a vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cjprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cjprod(io_err, n, m, gotj, jtrans, x, vector, lvector, result, lresult)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>gotj:    [IN] Vector{Cint}</li><li>jtrans:  [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>vector:  [IN] Vector{Cdouble}</li><li>lvector: [IN] Vector{Cint}</li><li>result:  [OUT] Vector{Cdouble}</li><li>lresult: [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3268-L3298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.clfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.clfg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.clfg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>clfg</strong></p><p>The clfg subroutine evaluates the value of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (X,Y), and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_clfg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">clfg(io_err, n, m, x, y, f, g, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1792-L1819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}, Matrix{UInt8}}" href="#CUTEst.cnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}, Matrix{UInt8}}"><code>CUTEst.cnames</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cnames</strong></p><p>The cnames subroutine obtains the names of the problem, its variables and general constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cnames</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cnames(io_err, n, m, pname, vname, cname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>pname:   [OUT] Vector{UInt8}</li><li>vname:   [OUT] Vector{UInt8}</li><li>cname:   [OUT] Vector{UInt8}</li></ul><p>To get useful names, use <code>String(x)</code> where <code>x</code> can be <code>pname</code>, <code>vname[:,i]</code>, or <code>cname[:,i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L665-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cofg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cofg</strong></p><p>The cofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cofg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cofg(io_err, n, x, f, g, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1612-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cofsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cofsg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cofsg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cofsg</strong></p><p>The cofsg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cofsg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cofsg(io_err, n, x, f, nnzg, lg, g_val, g_var, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li><li>nnzg:    [OUT] Vector{Cint}</li><li>lg:      [IN] Vector{Cint}</li><li>g_val:   [OUT] Vector{Cdouble}</li><li>g_var:   [OUT] Vector{Cint}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1658-L1686">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.connames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}" href="#CUTEst.connames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}"><code>CUTEst.connames</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>connames</strong></p><p>The connames subroutine obtains the names of the general constraints of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_connames</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">connames(io_err, m, cname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>cname:   [OUT] Vector{UInt8}</li></ul><p>To get useful names, use <code>String(cname[:,i])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L750-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cons_coord!-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cons_coord!-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cons_coord!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cons_coord!(nlp, x, c, rows, cols, vals)</code></pre><p>Computes the constraint vector and the Jacobian in coordinate format. Usage:</p><pre><code class="nohighlight hljs">cons_coord!(nlp, x, c, rows, cols, vals)</code></pre><ul><li>nlp:  [IN] CUTEstModel</li><li>x:    [IN] Vector{Float64}</li><li>c:    [OUT] Vector{Float64}</li><li>jrow: [OUT] Vector{Int32}</li><li>jcol: [OUT] Vector{Int32}</li><li>jval: [OUT] Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/julia_interface.jl#L147-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cons_coord-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cons_coord-Tuple{CUTEstModel, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cons_coord</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cons_coord(nlp, x)</code></pre><p>Computes the constraint vector and the Jacobian in coordinate format. Usage:</p><pre><code class="nohighlight hljs">c, jrow, jcol, jval = cons_coord(nlp, x)</code></pre><ul><li>nlp:  [IN] CUTEstModel</li><li>x:    [IN] Vector{Float64}</li><li>c:    [OUT] Vector{Float64}</li><li>jrow: [OUT] Vector{Int32}</li><li>jcol: [OUT] Vector{Int32}</li><li>jval: [OUT] Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/julia_interface.jl#L238-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.consjac-Tuple{CUTEstModel, AbstractVector}" href="#CUTEst.consjac-Tuple{CUTEstModel, AbstractVector}"><code>CUTEst.consjac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">consjac(nlp, x)</code></pre><p>Computes the constraint vector and the Jacobian in internal sparse format. Usage:</p><pre><code class="nohighlight hljs">c, J = consjac(nlp, x)</code></pre><ul><li>nlp:  [IN] CUTEstModel</li><li>x:    [IN] Vector{Float64}</li><li>c:    [OUT] Vector{Float64}</li><li>J:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/julia_interface.jl#L268-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.create_class-Tuple{}" href="#CUTEst.create_class-Tuple{}"><code>CUTEst.create_class</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>create_class()</code></p><p>Creates the file <code>classf.json</code>, running each problem in <code>$MASTSIF/CLASSF.DB</code> and extracting the necessary information. It should be left alone, unless you think it is not updated. If you do, please open an issue at <a href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl">https://github.com/JuliaSmoothOptimizers/CUTEst.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/create_class.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.creport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.creport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.creport</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>creport</strong></p><p>The creport subroutine obtains statistics concerning function evaluation and CPU time used for constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_creport</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">creport(io_err, calls, time)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>calls:   [OUT] Vector{Cdouble}</li><li>time:    [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L713-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Vararg{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, 5}}" href="#CUTEst.csetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Vararg{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, 5}}"><code>CUTEst.csetup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csetup</strong></p><p>The csetup subroutine sets up the correct data structures for subsequent computations on the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csetup</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csetup(io_err, input, out, io_buffer, n, m, x, x_l, x_u, y, c_l, c_u, equatn,</code></pre><p>linear, e<em>order, l</em>order, v_order)</p><ul><li>io_err:    [OUT] Vector{Cint}</li><li>input:     [IN] Vector{Cint}</li><li>out:       [IN] Vector{Cint}</li><li>io_buffer: [IN] Vector{Cint}</li><li>n:         [IN] Vector{Cint}</li><li>m:         [IN] Vector{Cint}</li><li>x:         [OUT] Vector{Cdouble}</li><li>x_l:       [OUT] Vector{Cdouble}</li><li>x_u:       [OUT] Vector{Cdouble}</li><li>y:         [OUT] Vector{Cdouble}</li><li>c_l:       [OUT] Vector{Cdouble}</li><li>c_u:       [OUT] Vector{Cdouble}</li><li>equatn:    [OUT] Vector{Cint}</li><li>linear:    [OUT] Vector{Cint}</li><li>e_order:   [IN] Vector{Cint}</li><li>l_order:   [IN] Vector{Cint}</li><li>v_order:   [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L131-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csgr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csgr</strong></p><p>The csgr subroutine evaluates the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients are stored in a sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csgr</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csgr(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>grlagf:  [IN] Vector{Cint}</li><li>nnzj:    [OUT] Vector{Cint}</li><li>lj:      [IN] Vector{Cint}</li><li>j_val:   [OUT] Vector{Cdouble}</li><li>j_var:   [OUT] Vector{Cint}</li><li>j_fun:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1927-L1960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csgreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csgreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgreh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csgreh</strong></p><p>The csgreh subroutine evaluates both the gradients of the general constraint functions and the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The subroutine also obtains the gradient of either the objective function or the Lagrangian function, stored in a sparse format. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csgreh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csgreh(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, ne,</code></pre><p>lhe<em>ptr, he</em>row<em>ptr, he</em>val<em>ptr, lhe</em>row, he<em>row, lhe</em>val, he_val, byrows)</p><ul><li>io_err:     [OUT] Vector{Cint}</li><li>n:          [IN] Vector{Cint}</li><li>m:          [IN] Vector{Cint}</li><li>x:          [IN] Vector{Cdouble}</li><li>y:          [IN] Vector{Cdouble}</li><li>grlagf:     [IN] Vector{Cint}</li><li>nnzj:       [OUT] Vector{Cint}</li><li>lj:         [IN] Vector{Cint}</li><li>j_val:      [OUT] Vector{Cdouble}</li><li>j_var:      [OUT] Vector{Cint}</li><li>j_fun:      [OUT] Vector{Cint}</li><li>ne:         [OUT] Vector{Cint}</li><li>lhe_ptr:    [IN] Vector{Cint}</li><li>he<em>row</em>ptr: [OUT] Vector{Cint}</li><li>he<em>val</em>ptr: [OUT] Vector{Cint}</li><li>lhe_row:    [IN] Vector{Cint}</li><li>he_row:     [OUT] Vector{Cint}</li><li>lhe_val:    [IN] Vector{Cint}</li><li>he_val:     [OUT] Vector{Cdouble}</li><li>byrows:     [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2867-L2914">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csgrp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csgrp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csgrp</strong></p><p>The csgrp subroutine evaluates sparsity pattern used when storing the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csgrp</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csgrp(io_err, n, nnzj, lj, j_var, j_fun)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>nnzj:       [OUT] Vector{Cint}</li><li>lj:         [IN] Vector{Cint}</li><li>j_var:      [OUT] Vector{Cint}</li><li>j_fun:      [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3650-L3671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csgrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csgrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrsh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csgrsh</strong></p><p>The csgrsh subroutine evaluates the gradients of the general constraints, the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) and the gradient of either the objective function or the Lagrangian corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The data is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csgrsh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csgrsh(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, nnzh, lh,</code></pre><p>h<em>val, h</em>row, h_col)</p><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>grlagf:  [IN] Vector{Cint}</li><li>nnzj:    [OUT] Vector{Cint}</li><li>lj:      [IN] Vector{Cint}</li><li>j_val:   [OUT] Vector{Cdouble}</li><li>j_var:   [OUT] Vector{Cint}</li><li>j_fun:   [OUT] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2770-L2809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csgrshp-NTuple{10, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csgrshp-NTuple{10, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csgrshp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csgrshp</strong></p><p>The csgrshp subroutine evaluates sparsity pattern used when storing the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x), as well as the Hessian of the Lagrangian function, corresponding to the problem decoded from a SIF file by the script sifdecoder.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csgrshp</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>nnzj:    [OUT] Vector{Cint}</li><li>lj:      [IN] Vector{Cint}</li><li>j_var:   [OUT] Vector{Cint}</li><li>j_fun:   [OUT] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3726-L3748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csh</strong></p><p>The csh subroutine evaluates the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csh(io_err, n, m, x, y, nnzh, lh, h_val, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2428-L2458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cshc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cshc-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cshc</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cshc</strong></p><p>The cshc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cshc</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cshc(io_err, n, m, x, y, nnzh, lh, h_val, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>m:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>y:       [IN] Vector{Cdouble}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2498-L2528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cshcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cshcprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cshcprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cshcprod</strong></p><p>The cshcprod subroutine forms the product of a sparse vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cshcprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cshcprod(io_err, n, m, goth, x, y, nnz_vector, index_nz_vector, vector,</code></pre><p>nnz<em>result, index</em>nz_result, result)</p><ul><li>io_err:          [OUT] Vector{Cint}</li><li>n:               [IN] Vector{Cint}</li><li>m:               [IN] Vector{Cint}</li><li>goth:            [IN] Vector{Cint}</li><li>x:               [IN] Vector{Cdouble}</li><li>y:               [IN] Vector{Cdouble}</li><li>nnz_vector:      [IN] Vector{Cint}</li><li>index<em>nz</em>vector: [IN] Vector{Cint}</li><li>vector:          [IN] Vector{Cdouble}</li><li>nnz_result:      [OUT] Vector{Cint}</li><li>index<em>nz</em>result: [OUT] Vector{Cint}</li><li>result:          [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3189-L3222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cshp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cshp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cshp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cshp</strong></p><p>The cshp subroutine evaluates the sparsity pattern of the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cshp</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cshp(io_err, n, nnzh, lh, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L2382-L2407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cshprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.cshprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.cshprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cshprod</strong></p><p>The cshprod subroutine forms the product of a sparse vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cshprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cshprod(io_err, n, m, goth, x, y, nnz_vector, index_nz_vector, vector,</code></pre><p>nnz<em>result, index</em>nz_result, result)</p><ul><li>io_err:          [OUT] Vector{Cint}</li><li>n:               [IN] Vector{Cint}</li><li>m:               [IN] Vector{Cint}</li><li>goth:            [IN] Vector{Cint}</li><li>x:               [IN] Vector{Cdouble}</li><li>y:               [IN] Vector{Cdouble}</li><li>nnz_vector:      [IN] Vector{Cint}</li><li>index<em>nz</em>vector: [IN] Vector{Cint}</li><li>vector:          [IN] Vector{Cdouble}</li><li>nnz_result:      [OUT] Vector{Cint}</li><li>index<em>nz</em>result: [OUT] Vector{Cint}</li><li>result:          [OUT] Vector{Cdouble}</li></ul><p>Notice that <code>vector</code> and <code>result</code> should have allocated dimension of <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3046-L3081">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.csjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.csjprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.csjprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>csjprod</strong></p><p>The csjprod subroutine forms the product of a sparse vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_csjprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">csjprod(io_err, n, m, gotj, jtrans, x, nnz_vector, index_nz_vector, vector,</code></pre><p>lvector, nnz<em>result, index</em>nz_result, result, lresult)</p><ul><li>io_err:          [OUT] Vector{Cint}</li><li>n:               [IN] Vector{Cint}</li><li>m:               [IN] Vector{Cint}</li><li>gotj:            [IN] Vector{Cint}</li><li>jtrans:          [IN] Vector{Cint}</li><li>x:               [IN] Vector{Cdouble}</li><li>nnz_vector:      [IN] Vector{Cint}</li><li>index<em>nz</em>vector: [IN] Vector{Cint}</li><li>vector:          [IN] Vector{Cdouble}</li><li>lvector:         [IN] Vector{Cint}</li><li>nnz_result:      [OUT] Vector{Cint}</li><li>index<em>nz</em>result: [OUT] Vector{Cint}</li><li>result:          [OUT] Vector{Cdouble}</li><li>lresult:         [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3338-L3373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cstats-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cstats-NTuple{5, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cstats</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cstats</strong></p><pre><code class="nohighlight hljs">cstats(io_err, nonlinear_variables_objective,</code></pre><p>nonlinear<em>variables</em>constraints, equality<em>constraints, linear</em>constraints)</p><ul><li>io_err:                          [OUT] Vector{Cint}</li><li>nonlinear<em>variables</em>objective:   [OUT] Vector{Cint}</li><li>nonlinear<em>variables</em>constraints: [OUT] Vector{Cint}</li><li>equality_constraints:            [OUT] Vector{Cint}</li><li>linear_constraints:              [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L598-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cterminate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cterminate</strong></p><p>The uterminate subroutine deallocates all workspace arrays created since the last call to csetup.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cterminate</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cterminate(io_err)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3548-L3562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.cvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.cvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.cvartype</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>cvartype</strong></p><p>The cvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_cvartype</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">cvartype(io_err, n, x_type)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x_type:  [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L628-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.pname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}" href="#CUTEst.pname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}"><code>CUTEst.pname</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>pname</strong></p><p>The pname subroutine obtains the name of the problem directly from the datafile OUTSDIF.d that was created by the script sifdecoder when decoding a SIF file. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_pname</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">pname(io_err, input, pname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>input:   [IN] Vector{Cint}</li><li>pname:   [OUT] Vector{UInt8}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L784-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.probname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}" href="#CUTEst.probname-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}}"><code>CUTEst.probname</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>probname</strong></p><p>The probname subroutine obtains the name of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_probname</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">probname(io_err, pname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>pname:   [OUT] Vector{UInt8}</li></ul><p>To get a useful name, use <code>String(pname)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L821-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.select-Tuple{}" href="#CUTEst.select-Tuple{}"><code>CUTEst.select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select(;min_var=1, max_var=Inf, min_con=0, max_con=Inf,
        objtype=*, contype=*,
        only_free_var=false, only_bnd_var=false,
        only_linear_con=false, only_nonlinear_con=false,
        only_equ_con=false, only_ineq_con=false,
        custom_filter=*)</code></pre><p>Returns a subset of the CUTEst problems using the classification file <code>classf.json</code>. This file is export together with the package, so if you have an old CUTEst installation, it can lead to inconsistencies.</p><ul><li><code>min_var</code> and <code>max_var</code> set the number of variables in the problem;</li><li><code>min_con</code> and <code>max_con</code> set the number of constraints in the problem</li></ul><p>(e.g., use <code>max_con=0</code> for unconstrained or <code>min_con=1</code> for constrained)</p><ul><li><code>only_*</code> flags are self-explaining. Note that they appear in conflicting</li></ul><p>pairs. Both can be false, but only one can be true.</p><ul><li><code>objtype</code> is the classification of the objective function according to the</li></ul><p><a href="https://www.cuter.rl.ac.uk/Problems/classification.shtml">MASTSIF classification file</a>. It can be a number, a symbol, a string, or an array of those.</p><pre><code class="nohighlight hljs">1, :none or &quot;none&quot; means there is no objective function;
2, :constant or &quot;constant&quot; means the objective function is a constant;
3, :linear or &quot;linear&quot; means the objective function is a linear functional;
4, :quadratic or &quot;quadratic&quot; means the objective function is quadratic;
5, :sum_of_squares or &quot;sum_of_squares&quot; means the objective function is a sum of squares
6, :other or &quot;other&quot; means the objective function is none of the above.</code></pre><ul><li><p><code>contype</code> is the classification of the constraints according to the same MASTSIF classification file.</p><p>1, :unc or &quot;unc&quot; means there are no constraints at all;   2, :fixed<em>vars or &quot;fixed</em>vars&quot; means the only constraints are fixed variables;   3, :bounds or &quot;bounds&quot; means the only constraints are bounded variables;   4, :network or &quot;network&quot; means the constraints represent the adjacency matrix of a (linear) network;   5, :linear or &quot;linear&quot; means the constraints are linear;   6, :quadratic or &quot;quadratic&quot; means the constraints are quadratic;   7, :other or &quot;other&quot; means the constraints are more general.</p></li><li><p><code>custom_filter</code> is a function to be applied to the problem data, which is a dict with the following fields:</p><p>&quot;objtype&quot;           - String    one of the above objective function types   &quot;contype&quot;           - String    one of the above constraint types   &quot;regular&quot;           - Bool      whether the problem is regular or not   &quot;derivative<em>order&quot;  - Int       order of the highest derivative available   &quot;origin&quot;            - String    origin of the problem: &quot;academic&quot;, &quot;modelling&quot; or &quot;real&quot;   &quot;has</em>interval<em>var&quot;  - Bool      whether it has interval variables   &quot;variables&quot;         - Dict with the following fields     &quot;can</em>choose&quot;      - Bool      whether you can change the number of variables via parameters     &quot;number&quot;          - Int       the number of variables (if <code>can_choose</code>, the default)     &quot;fixed&quot;           - Int       the number of fixed variables     &quot;free&quot;            - Int       the number of free variables     &quot;bounded<em>below&quot;   - Int       the number of variables bounded only from below     &quot;bounded</em>above&quot;   - Int       the number of variables bounded only from above     &quot;bounded<em>both&quot;    - Int       the number of variables bounded from below and above   &quot;constraints&quot;       - Dict with the following fields     &quot;can</em>choose&quot;      - Bool      whether you can change the number of constraints via parameters     &quot;number&quot;          - Int       the number of constraints (if <code>can_choose</code>, the default)     &quot;equality&quot;        - Int       the number of equality constraints     &quot;ineq<em>below&quot;      - Int       the number of inequalities of the form c(x) ≧ cl     &quot;ineq</em>above&quot;      - Int       the number of inequalities of the form c(x) ≦ cu     &quot;ineq_both&quot;       - Int       the number of inequalities of the form cl ≦ c(x) ≦ cu     &quot;linear&quot;          - Int       the number of linear constraints     &quot;nonlinear&quot;       - Int       the number of nonlinear constraints</p></li></ul><p>For instance, if you&#39;d like to choose only problems with fixed number of   variables, you can pass</p><pre><code class="nohighlight hljs">custom_filter=x-&gt;x[&quot;variables&quot;][&quot;can_choose&quot;]==false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/classification.jl#L32-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.set_mastsif-Tuple{}" href="#CUTEst.set_mastsif-Tuple{}"><code>CUTEst.set_mastsif</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_mastsif()</code></pre><p>Set the MASTSIF environment variable to point to the main SIF collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/CUTEst.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.sifdecoder-Tuple{AbstractString, Vararg{Any}}" href="#CUTEst.sifdecoder-Tuple{AbstractString, Vararg{Any}}"><code>CUTEst.sifdecoder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Decode problem and build shared library.</p><p>Optional arguments are passed directly to the SIF decoder. Example:     <code>sifdecoder(&quot;DIXMAANJ&quot;, &quot;-param&quot;, &quot;M=30&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/CUTEst.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ubandh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ubandh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ubandh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ubandh</strong></p><p>The ubandh subroutine extracts the elements which lie within a band of given semi-bandwidth out of the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ubandh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ubandh(io_err, n, x, semibandwidth, h_band, lbandh, max_semibandwidth)</code></pre><ul><li>io_err:            [OUT] Vector{Cint}</li><li>n:                 [IN] Vector{Cint}</li><li>x:                 [IN] Vector{Cdouble}</li><li>semibandwidth:     [IN] Vector{Cint}</li><li>h_band:            [OUT] Array{Cdouble, 2}</li><li>lbandh:            [IN] Vector{Cint}</li><li>max_semibandwidth: [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1518-L1543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.udh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.udh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.udh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>udh</strong></p><p>The udh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_udh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">udh(io_err, n, x, lh1, h)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>lh1:     [IN] Vector{Cint}</li><li>h:       [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L998-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.udimen-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.udimen-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimen</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>udimen</strong></p><p>The udimen subroutine discovers how many variables are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_udimen</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">udimen(io_err, input, n)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>input:   [IN] Vector{Cint}</li><li>n:       [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L229-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.udimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.udimse-NTuple{4, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimse</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>udimse</strong></p><p>The udimse subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H_i involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_udimse</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">udimse(io_err, ne, he_val_ne, he_row_ne)</code></pre><ul><li>io_err:    [OUT] Vector{Cint}</li><li>ne:        [OUT] Vector{Cint}</li><li>he<em>val</em>ne: [OUT] Vector{Cint}</li><li>he<em>row</em>ne: [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L287-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.udimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.udimsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.udimsh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>udimsh</strong></p><p>The udimsh subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_udimsh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">udimsh(io_err, nnzh)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L263-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ueh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ueh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ueh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ueh</strong></p><p>The ueh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ueh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ueh(io_err, n, x, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row,</code></pre><p>lhe<em>val, he</em>val, byrows)</p><ul><li>io_err:     [OUT] Vector{Cint}</li><li>n:          [IN] Vector{Cint}</li><li>x:          [IN] Vector{Cdouble}</li><li>ne:         [OUT] Vector{Cint}</li><li>lhe_ptr:    [IN] Vector{Cint}</li><li>he<em>row</em>ptr: [OUT] Vector{Cint}</li><li>he<em>val</em>ptr: [OUT] Vector{Cint}</li><li>lhe_row:    [IN] Vector{Cint}</li><li>he_row:     [OUT] Vector{Cint}</li><li>lhe_val:    [IN] Vector{Cint}</li><li>he_val:     [OUT] Vector{Cdouble}</li><li>byrows:     [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1134-L1166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ufn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.ufn-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ufn</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ufn</strong></p><p>The ufn subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ufn</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ufn(io_err, n, x, f)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L880-L900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ugr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.ugr-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ugr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ugr</strong></p><p>The ugr subroutine evaluates the gradient of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ugr</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ugr(io_err, n, x, g)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L917-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ugrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}" href="#CUTEst.ugrdh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{Float64}}"><code>CUTEst.ugrdh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ugrdh</strong></p><p>The ugrdh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ugrdh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ugrdh(io_err, n, x, g, lh1, h)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li><li>lh1:     [IN] Vector{Cint}</li><li>h:       [OUT] Array{Cdouble, 2}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1212-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ugreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ugreh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ugreh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ugreh</strong></p><p>The ugreh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H sub e involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ugreh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ugreh(io_err, n, x, g, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row,</code></pre><p>lhe<em>val, he</em>val, byrows)</p><ul><li>io_err:     [OUT] Vector{Cint}</li><li>n:          [IN] Vector{Cint}</li><li>x:          [IN] Vector{Cdouble}</li><li>g:          [OUT] Vector{Cdouble}</li><li>ne:         [OUT] Vector{Cint}</li><li>lhe_ptr:    [IN] Vector{Cint}</li><li>he<em>row</em>ptr: [OUT] Vector{Cint}</li><li>he<em>val</em>ptr: [OUT] Vector{Cint}</li><li>lhe_row:    [IN] Vector{Cint}</li><li>he_row:     [OUT] Vector{Cint}</li><li>lhe_val:    [IN] Vector{Cint}</li><li>he_val:     [OUT] Vector{Cdouble}</li><li>byrows:     [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1321-L1355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ugrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ugrsh-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ugrsh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ugrsh</strong></p><p>The ugrsh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ugrsh</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ugrsh(io_err, n, x, g, nnzh, lh, h_val, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1257-L1284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.uhprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.uhprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.uhprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>uhprod</strong></p><p>The uhprod subroutine forms the product of a vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_uhprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">uhprod(io_err, n, goth, x, vector, result)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>goth:    [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>vector:  [IN] Vector{Cdouble}</li><li>result:  [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1404-L1427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.unames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}}" href="#CUTEst.unames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{UInt8, 1, Vector{UInt8}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{UInt8}}, Matrix{UInt8}}"><code>CUTEst.unames</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>unames</strong></p><p>The unames subroutine obtains the names of the problem and its variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_unames</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">unames(io_err, n, pname, vname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>pname:   [OUT] Vector{UInt8}</li><li>vname:   [OUT] Vector{UInt8}</li></ul><p>To get useful names, use <code>String(x)</code> where <code>x</code> can be <code>pname</code> or <code>vname[:,i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L363-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.uofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.uofg-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uofg</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>uofg</strong></p><p>The uofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_uofg</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">uofg(io_err, n, x, f, g, grad)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>f:       [OUT] Vector{Cdouble}</li><li>g:       [OUT] Vector{Cdouble}</li><li>grad:    [IN] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L954-L977">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ureport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.ureport-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ureport</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ureport</strong></p><p>The ureport subroutine obtains statistics concerning function evaluation and CPU time used for unconstrained or bound-constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ureport</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ureport(io_err, calls, time)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>calls:   [OUT] Vector{Cdouble}</li><li>time:    [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L401-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.usetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.usetup-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.usetup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>usetup</strong></p><p>The usetup subroutine sets up the correct data structures for subsequent computations in the case where the only possible constraints are bound constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_usetup</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">usetup(io_err, input, out, io_buffer, n, x, x_l, x_u)</code></pre><ul><li>io_err:    [OUT] Vector{Cint}</li><li>input:     [IN] Vector{Cint}</li><li>out:       [IN] Vector{Cint}</li><li>io_buffer: [IN] Vector{Cint}</li><li>n:         [IN] Vector{Cint}</li><li>x:         [OUT] Vector{Cdouble}</li><li>x_l:       [OUT] Vector{Cdouble}</li><li>x_u:       [OUT] Vector{Cdouble}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L72-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ush-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ush-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ush</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ush</strong></p><p>The ush subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ush</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ush(io_err, n, x, nnzh, lh, h_val, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x:       [IN] Vector{Cdouble}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_val:   [OUT] Vector{Cdouble}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1083-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ushp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.ushp-NTuple{6, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.ushp</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ushp</strong></p><p>The ushp subroutine evaluates the sparsity pattern of the Hessian matrix of the objective function of the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ushp</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ushp(io_err, n, nnzh, lh, h_row, h_col)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>nnzh:    [OUT] Vector{Cint}</li><li>lh:      [IN] Vector{Cint}</li><li>h_row:   [OUT] Vector{Cint}</li><li>h_col:   [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1039-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.ushprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}" href="#CUTEst.ushprod-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Float64}}}"><code>CUTEst.ushprod</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>ushprod</strong></p><p>The ushprod subroutine forms the product of a sparse vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_ushprod</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">ushprod(io_err, n, goth, x, nnz_vector, index_nz_vector, vector, nnz_result,</code></pre><p>index<em>nz</em>result, result)</p><ul><li>io_err:          [OUT] Vector{Cint}</li><li>n:               [IN] Vector{Cint}</li><li>goth:            [IN] Vector{Cint}</li><li>x:               [IN] Vector{Cdouble}</li><li>nnz_vector:      [IN] Vector{Cint}</li><li>index<em>nz</em>vector: [IN] Vector{Cint}</li><li>vector:          [IN] Vector{Cdouble}</li><li>nnz_result:      [OUT] Vector{Cint}</li><li>index<em>nz</em>result: [OUT] Vector{Cint}</li><li>result:          [OUT] Vector{Cdouble}</li></ul><p>Notice that <code>vector</code> and <code>result</code> should have allocated dimension of <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L1448-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.uterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.uterminate-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uterminate</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>uterminate</strong></p><p>The uterminate subroutine deallocates all workspace arrays created since the last call to usetup.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_uterminate</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">uterminate(io_err)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L3530-L3544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.uvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}" href="#CUTEst.uvartype-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}}"><code>CUTEst.uvartype</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>uvartype</strong></p><p>The uvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_uvartype</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">uvartype(io_err, n, x_type)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>x_type:  [OUT] Vector{Cint}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L328-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CUTEst.varnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}" href="#CUTEst.varnames-Tuple{Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Union{SubArray{Int32, 1, Vector{Int32}, Tuple{UnitRange{U}}, true} where U&lt;:Integer, Vector{Int32}}, Matrix{UInt8}}"><code>CUTEst.varnames</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>varnames</strong></p><p>The varnames subroutine obtains the names of the problem variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p><p>For more information, run the shell command</p><pre><code class="nohighlight hljs">man cutest_varnames</code></pre><p>Usage:</p><pre><code class="nohighlight hljs">varnames(io_err, n, vname)</code></pre><ul><li>io_err:  [OUT] Vector{Cint}</li><li>n:       [IN] Vector{Cint}</li><li>vname:   [OUT] Vector{UInt8}</li></ul><p>To get useful names, use <code>String(vname[:, i])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/blob/e49d585e0091c626db41d3d4017e1070a5354b9b/src/core_interface.jl#L846-L869">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core/">« Core</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 24 May 2024 15:18">Friday 24 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
